#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <stdbool.h>
#include <time.h>

#define FILE_NAME "SAVE.dat"
#define HISTORY_NUM 20
#define LEN_OF_NAME 20

#define min(x,y) (x<y?x:y)

/*
 * ***field discription***
 *  0-8   .....numOfBomb
 *  9     .....bombInHere
 *  10-18 .....OpenedBlock(NumOfBomb-10)
 *  20-29 .....flaged here(0-9)
 */
typedef struct{
  int width;
  int height;
  int numOfBombs;
  int **field;
} field_t;/*field*/

typedef struct{
  char name[LEN_OF_NAME];
  int width;
  int height;
  int numOfBombs;
  int sec;
  time_t time;
} score_t;

typedef struct{
  score_t scores[HISTORY_NUM];
  int num;
} saveFile_t;

typedef struct{
  int x;
  int y;
} vector_t;/*vector*/

vector_t add(vector_t a,vector_t b);/*add two vectors*/
int distSq(vector_t a,vector_t b);/*distance from 2 points*/
vector_t calcMotion(char ch);/*calcMotion*/
void calcCursor(field_t *field,char ch,vector_t *cursor);/*cursor motion*/

void removeEnter(char *str);/*remove Enter from string*/
bool keyTask(field_t *field,vector_t *cursor,unsigned int time,saveFile_t *save,char key,bool *isStarted);/*key tasks*/
int initValue(field_t *field,int argc,const char **argv);/*initialize value*/
int initGame(field_t *field);/*initialize game*/
void exitGame(field_t *field);/*deinitialize game*/
int setBombs(field_t *field,vector_t *cursor);/*set bombs(cursor requred)*/
int newField(field_t *field);/*make new field*/
void freeField(field_t *field);/*free field*/
int numOfFlags(field_t *field,vector_t *p);/*count around flags*/

void dispMessage(field_t *field);/*start up message*/
void dispElement(int num);/*display Element of map*/
void dispField(field_t *field,vector_t *cursor);/*disp map*/

void open(field_t *field,vector_t p);/*open tile*/
void putFlag(field_t *field,vector_t *p);/*put flag*/
bool isGameClear(field_t *field);/*game clear judgment*/
bool isGameOver(field_t *field);/*game over judgment*/

void gameOverEvent(field_t *field,vector_t *cursor);/*game over events*/
void gameClearEvent(field_t *field,vector_t *cursor);/*game clear events*/

void dispSave(saveFile_t *save);/*display save datas*/
void addSave(saveFile_t *save,field_t *field,int clearTime,const char *name);/*add save datas*/
int loadFile(saveFile_t *save,FILE *fp);/*load save datas*/
void saveFile(saveFile_t *save,FILE *fp);/*save save datas*/

/*Around escape sequence*/
#define COL_RED        1
#define COL_GREEN    2
#define COL_YELLOW    3
#define COL_BLUE    4
#define COL_PINK    5
#define COL_CYAN    6
#define COL_WHITE    7
#define COL_RESET    9

#define SET_BACKGROUND_COL(col)     printf("\033[4%dm",col)
#define SET_FRONTGROUND_COL(col)    printf("\033[3%dm",col)
#define REVERCE_BACKGROUND_FRONTGROUND_COL() printf("\033[7m")
#define RESET_SETTING() printf("\033[0m")
#define CLR_SCREEN() printf("\033[2J")
#define SET_CURSOR(x,y) printf("\033[%d;%dH",y+1,x+1)

/*key settings*/
const struct{
  char key;
  vector_t move;
} KEYS[]={
  {'4',{-1,0}},
  {'8',{0,-1}},
  {'6',{1,0}},
  {'2',{0,1}},
  {'7',{-1,-1}},
  {'9',{1,-1}},
  {'1',{-1,1}},
  {'3',{1,1}},
};

/*number of flags in field*/
int numOfFlagsinField;

int main(int argc,const char **argv){
  srand(255132);
  char ch;
  field_t field;
  vector_t cursor={0,0};
  bool isStarted = false;
  time_t startTime = time(NULL);
  FILE *fp;
  saveFile_t save = {0};

  if(initValue(&field,argc,argv))return EXIT_FAILURE;

 
  fp = fopen(FILE_NAME,"r");
  if(fp==NULL){}
  else{
    if(loadFile(&save,fp)!=EXIT_SUCCESS)return EXIT_FAILURE;
    fclose(fp);
  }
 
  dispMessage(&field); 
  if(initGame(&field)!=EXIT_SUCCESS){
    printf("cannot initialize\n");
    return EXIT_FAILURE;
  }

  CLR_SCREEN();
  dispField(&field,&cursor);
  time(&startTime);

  do{
    ch = getchar();
   
  }while(keyTask(
         &field,
         &cursor,
         time(NULL)-startTime,
         &save,
         ch,
         &isStarted
         )
     );
  exitGame(&field);

  return EXIT_SUCCESS;
}

/*
 *key tasks
 *return...isContinue?
 */
bool keyTask(field_t *field,vector_t *cursor,unsigned int time,saveFile_t *save,char key,bool *isStarted){
  if(isdigit(key)&&key!='0'&&key!='5'){
    calcCursor(field,key,cursor);
  }

  if(key == '\n'||key=='5'){
    if(!*isStarted){
      *isStarted = true;
      if(setBombs(field,cursor) == EXIT_FAILURE){
    printf("cannot put bombs\n");
    return false;
      }
    }
    if(field->field[cursor->y][cursor->x]<19)
      open(field,*cursor);
    if(isGameOver(field)){
      gameOverEvent(field,cursor);
      return false;
    }
  }
  else if(key == 'e')return false;
  else if(key == 'f'&&*isStarted)putFlag(field,cursor);
  CLR_SCREEN();
  printf("time:%u\n",time);
  dispField(field,cursor);
  if(*isStarted&&isGameClear(field)){
    FILE *fp;
    char name[LEN_OF_NAME];
   
    if(system("stty echo -icanon min 1 time 0")<0){
      printf("echo setting failed\n");
    }
    gameClearEvent(field,cursor);

    fp = fopen(FILE_NAME,"w");
    if(fp == NULL){
      printf("file cannot open[%s]\n",FILE_NAME);
      return false;
    }
    printf("yout name please(up to %d)\n",LEN_OF_NAME-2);
    fgets(name,LEN_OF_NAME,stdin);
    removeEnter(name);
    printf("your name is %s.\n",name);

    addSave(save,field,time,name);
    saveFile(save,fp);

    fclose(fp);
    dispSave(save);
    return false;
  }
  return true;
}

void removeEnter(char *str){
  while(*str!='\n')str++;
  *str = '\0';
}

/*is str is number?*/
bool isNumber(const char *str){
  while(isdigit(*str))str++;
  return *str == '\0';
}

/*initialize value*/
int initValue(field_t *field,int argc,const char **argv){ 
  if(argc == 1){
    field->width = 15;
    field->height = 15;
    field->numOfBombs = 30;
  }
  else if(argc == 4){
    if(isNumber(argv[1]))
      field->width = atoi(argv[1]);
    else{
      printf("%s is NOT correct!!(width)\n",argv[1]);
      return EXIT_FAILURE;
    }
    if(isNumber(argv[2]))
      field->height = atoi(argv[2]);
    else{
      printf("%s is NOT correct!!(height)\n",argv[2]);
      return EXIT_FAILURE;
    }
    if(isNumber(argv[3]))
      field->numOfBombs = atoi(argv[3]);
    else{
      printf("%s is NOT correct!! (bombs)\n",argv[3]);
      return EXIT_FAILURE;
    }
  }
  else{
    printf("Num of args must be 0 or 3.\n[width] [height] [num of bombs]\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

void dispSave(saveFile_t *save){
  int i;
  int j;
  struct tm *t_st;
  if(save->num < HISTORY_NUM){
    i=0;
  }
  else{
    i=(save->num)%HISTORY_NUM;
  }

  printf("===HISTORY===\n");
  for(j=0;j<min(HISTORY_NUM,save->num);i++,j++){
    t_st = localtime(&save->scores[i%HISTORY_NUM].time);
    printf("%-*s %02d/%02d %02d:%02d %-3d*%-3d[%-3d]%2dm%2ds\n"
       ,LEN_OF_NAME
       ,save->scores[i%HISTORY_NUM].name
       ,t_st->tm_mon+1
       ,t_st->tm_mday
       ,t_st->tm_hour
       ,t_st->tm_min
       ,save->scores[i%HISTORY_NUM].width
       ,save->scores[i%HISTORY_NUM].height
       ,save->scores[i%HISTORY_NUM].numOfBombs
       ,save->scores[i%HISTORY_NUM].sec/60
       ,save->scores[i%HISTORY_NUM].sec%60
       );
  }
}

void addSave(saveFile_t *save,field_t *field,int clearTime,const char *name){
  sprintf(
  save->scores[save->num%HISTORY_NUM].name,
  "%s",
  name);
  save->scores[save->num%HISTORY_NUM].width = field->width;
  save->scores[save->num%HISTORY_NUM].height = field->height;
  save->scores[save->num%HISTORY_NUM].numOfBombs = field->numOfBombs;
  save->scores[save->num%HISTORY_NUM].time = time(NULL);
  save->scores[save->num%HISTORY_NUM].sec = clearTime;
  save->num++;
}

int loadFile(saveFile_t *save,FILE *fp){
  int read;
  read = fread(save,sizeof(saveFile_t),1,fp);
  if(read == 1){
    return EXIT_SUCCESS;
  }
  printf("IS NOT SAVE DATA!![%d]\n",read);
  return EXIT_FAILURE;
}

void saveFile(saveFile_t *save,FILE *fp){
  fwrite(save,sizeof(saveFile_t),1,fp);
}

/*start message*/
void dispMessage(field_t *field){
  printf("===Mine Sweeper===\n");
  printf(" 　＿＿\n");
  printf(" ／　 　＼\n");
  printf("|／▼ ▼ ＼ |\n");
  printf("|　ヽ＿/  |\n");
  printf(" ＼＿＿_／　\n");
  printf("\nPlz confirm configulation...\n");
  printf("[%-*s]:%d\n",15,"width of field",field->width);
  printf("[%-*s]:%d\n",15,"height of field",field->height);
  printf("[%-*s]:%d\n",15,"number of bombs",field->numOfBombs);
  printf("If you will edit these elements, you must put the argument!\n");
  printf("[width] [height] [numOfBomb]\n\n");
  printf("Enter to continue...");
  while(getchar()!='\n');

  printf("Plz confirm key settings...\n");
  printf("[%-*s]...%s.\n",8,"Enter,5","Dig (if put flag, dig around)");
  printf("[%-*s]...%s.\n",8,"F","Put flag");
  printf("[%-*s]...%s.\n",8,"4","Move cursor to the left");
  printf("[%-*s]...%s.\n",8,"8","Move cursor to the up");
  printf("[%-*s]...%s.\n",8,"6","Move cursor to the right");
  printf("[%-*s]...%s.\n",8,"2","Move cursor to the down");
  printf("[%-*s]...%s.\n",8,"7","Move cursor to the upper left");
  printf("[%-*s]...%s.\n",8,"9","Move cursor to the upper right");
  printf("[%-*s]...%s.\n",8,"1","Move cursor to the lower left");
  printf("[%-*s]...%s.\n",8,"3","Move cursor to the lower right");
  printf("[%-*s]...%s.\n",8,"E","Exit game");
 
  printf("\
That it! Have fun!\n\
Enter to continue...");
  while(getchar()!='\n');
}

/*is game overed?*/
bool isGameOver(field_t *field){
  int x,y;
  for(x=0;x<field->width;x++){
    for(y=0;y<field->height;y++){
      if(field->field[y][x]==19)
    return true;
    }
  }
  return false;
} 

/*is game cleared?*/
bool isGameClear(field_t *field){
  int x,y;
  for(x=0;x<field->width;x++){
    for(y=0;y<field->height;y++){
      if((field->field[y][x]>=20&&field->field[y][x]<=28)||
     (field->field[y][x]>=0 &&field->field[y][x]<=8))
    return false;
    }
  }
  return true;
}

/*cursor motion calculate*/
vector_t calcMotion(char ch){
  unsigned int i;
  for(i=0;i<sizeof(KEYS)/sizeof(KEYS[0]);i++){
    if(KEYS[i].key == ch){
      return KEYS[i].move;
    }
  }
  assert(0);
  return KEYS[0].move;
}

void calcCursor(field_t *field,char ch,vector_t *cursor){
  *cursor = add(*cursor,calcMotion(ch));
  if(field->width <= cursor->x){    cursor -> x = field->width-1;  }
  else if(0 > cursor->x)cursor->x = 0;
  if(field->height <= cursor->y){    cursor -> y = field->height-1;  }
  else if(0 > cursor->y)cursor->y = 0;
}

/*is p in field?*/
bool isInField(field_t *field,vector_t *p){
  return
    field->width  > p->x && 0 <= p->x&&
    field->height > p->y && 0 <= p->y;
}

/*game initialize*/
int initGame(field_t *field){
  int res;

  assert(field->width>0);
  assert(field->height>0);
  assert(field->numOfBombs>=0);

  numOfFlagsinField = 0;
 
  res = newField(field);
  if(res == EXIT_FAILURE){
    return EXIT_FAILURE;
  }

  if(system("stty -echo -icanon min 1 time 0")<0){
    printf("echo setting failed\n");
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}

/*exit game*/
void exitGame(field_t *field){
  freeField(field);
  if(system("stty echo -icanon min 1 time 0")<0){
    printf("echo setting failed\n");
  }
}

/*Clear,Over Events*/
void gameClearEvent(field_t *field,vector_t *cursor){
  int x,y;
  for(x=0;x<field->width;x++){
    for(y=0;y<field->height;y++){
      if(field->field[y][x]==9)
    field->field[y][x]+=20;
      else if(field->field[y][x]<9){
    field->field[y][x]+=10;
      }
    }
  }
  dispField(field,cursor);
  printf("Game cleard\nThank you for playing!\n");
}

void gameOverEvent(field_t *field,vector_t *cursor){
  int x,y;
  for(x=0;x<field->width;x++){
    for(y=0;y<field->height;y++){
      if(field->field[y][x]<=9)
    field->field[y][x]+=10;
    }
  }
  dispField(field,cursor);
  printf("Bomb exploded!!\nYou dead。。。\n");
}

/*put bombs*/
int setBombs(field_t *field,vector_t *cursor){
  vector_t *candidi;
  size_t numofcandidi;

  unsigned int i = 0;

  numofcandidi = field->height*field->width-4;/*width*height-4が最大数(角)*/

  candidi = (vector_t*)malloc(sizeof(vector_t)*numofcandidi);

  if(candidi == NULL)return EXIT_FAILURE;
  {//calc candidicate
    vector_t p;

    for(p.y=0;p.y<field->height;p.y++){
      for(p.x=0;p.x<field->width;p.x++){
    if(distSq(p,*cursor)>2){
      candidi[i++]=p;
    }
      }
    }
  }

  numofcandidi = (size_t)i;
  {//sort by random
    vector_t tmp;
    int randnum;
    for(i=0;i<numofcandidi;i++){
      randnum = rand()%numofcandidi;
      tmp = candidi[i];
      candidi[i] = candidi[randnum];
      candidi[randnum] = tmp;
    }
  }

  if(numofcandidi < (unsigned int)field->numOfBombs){
    printf("cannot put bombs ...\ncandidi:%lu\n",numofcandidi);
    return EXIT_FAILURE;
  }
  {/*count up around bombs*/
    int j;
    vector_t tmp;
    for(i = 0;i < (unsigned int)field->numOfBombs;i++){
      field->field[candidi[i].y][candidi[i].x] = 9;
      for(j=0;j<(int)(sizeof(KEYS)/sizeof(KEYS[0]));j++){
    tmp = add(KEYS[j].move,candidi[i]);
    if(isInField(field,&tmp)){
      if(field->field[tmp.y][tmp.x]!=9){
        field->field[tmp.y][tmp.x]++;
      }
    }
      }
    }
  }
  free(candidi);

  return EXIT_SUCCESS;
}

/*set flag*/
void putFlag(field_t *field,vector_t *p){
  assert(isInField(field,p));
  if(field->field[p->y][p->x] < 10){
    field->field[p->y][p->x]+=20;
    numOfFlagsinField++;
  }
  else if(field->field[p->y][p->x] >= 20&&
      field->field[p->y][p->x] < 30){
    field->field[p->y][p->x]-=20;
    numOfFlagsinField--;
  }
}

/*open tiles*/
void open(field_t *field,vector_t p){
  vector_t tmp;
  int i;

  assert(isInField(field,&p));
  if(field->field[p.y][p.x] < 10)
    field->field[p.y][p.x] += 10;/*open tile*/
  if(numOfFlags(field,&p)==field->field[p.y][p.x]-10){
    for(i=0;i<(int)(sizeof(KEYS)/sizeof(KEYS[0]));i++){/*open around*/
      tmp = add(p,KEYS[i].move);
      if(isInField(field,&tmp)){
	if(field->field[tmp.y][tmp.x]<10)/*have not opended yet*/
	  open(field,tmp);
      }
    }
  }
}

/*allocate map*/
int newField(field_t *field){
  unsigned int height = field->height;
 
  field->field = calloc(sizeof(int*),field->height);

  int **fld = field->field;

  if(fld==NULL)return EXIT_FAILURE;
 
  do{
    *fld = calloc(sizeof(int),field->width);
    if(*fld++==NULL)return EXIT_FAILURE;
  }while(--height);

  return EXIT_SUCCESS;
}

void freeField(field_t *field){
  unsigned int height = field->height;
  int **fld = field->field;

  do{
    free(*(fld++));
  }while(--height);

  free(field->field);
}

/*count flags(around p)*/
int numOfFlags(field_t *field,vector_t *p){
  int i;
  int numOfFlags=0;
  vector_t tmp;

  for(i=0;i<(int)(sizeof(KEYS)/sizeof(KEYS[0]));i++){
    tmp = add(*p,KEYS[i].move);
    if(isInField(field,&tmp)){
      if(field->field[tmp.y][tmp.x]>=20){
    numOfFlags++;
      }
    }
  }
  return numOfFlags;
}

/*display maps functions*/
void dispElement(int num){
  assert(num>=0);
  if(num < 10){
      printf("#");
  }
  else if(num < 20){
    if(num == 10){printf(" ");}
    else if(num <= 18){
      printf("%d",num-10);
    }
    else if(num == 19){
      SET_BACKGROUND_COL(COL_RED);
      printf("B");
      SET_BACKGROUND_COL(COL_RESET);
    }
  }
  else if(num < 30){
    SET_BACKGROUND_COL(COL_GREEN);
    printf("F");
    SET_BACKGROUND_COL(COL_RESET);
  }
  else
    assert(0);
}

/*display field*/
void dispField(field_t *field,vector_t *cursor){
  int x,y;
  int **fld = field->field;

  for(x=0;x<field->width;x++){
    printf("+-");
  }
  printf("+\n");
  for(y=0;y<field->height;y++){
    for(x=0;x<field->width;x++){
      if(cursor->x==x&&y==cursor->y){
    printf("[");
    REVERCE_BACKGROUND_FRONTGROUND_COL();
      }
      else if(cursor->x==x-1&&y==cursor->y)printf("]");
      else printf("|");
      dispElement(fld[y][x]);
      RESET_SETTING();
    }
    if(cursor->x==x-1&&y==cursor->y)printf("]\n");
    else printf("|\n");
  }
  for(x=0;x<field->width;x++){
    printf("+-");
  }
  printf("+\n");
  printf("num of flags %d/%d\n",numOfFlagsinField,field->numOfBombs);
}

/*vector functions*/
/*add two vectors*/
vector_t add(vector_t a,vector_t b){
  vector_t res;

  res.x = a.x+b.x;
  res.y = a.y+b.y;

  return res;
}

/*sqare of distance from a to b*/
int distSq(vector_t a,vector_t b){
  return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}
